#!/usr/bin/env python
from distorm3 import Decode, Decode32Bits, Decode64Bits
from subprocess import check_output
from mmap import mmap
import sys, os, re, tempfile

READELF = '/usr/bin/readelf'
PAGE_SIZE = 4096

def asm(s):
    with tempfile.NamedTemporaryFile() as tmp:
        tmp.write(s)
        tmp.flush()
        r = check_output(['nasm', '-o', '/dev/stdout', tmp.name])
    return r

def die(s):
    print s
    exit(0)

if not (os.access(READELF, os.X_OK) and os.path.isfile(READELF)):
    die('Missing /usr/bin/readelf, please install binutils')

target = sys.argv[1]

if not (os.access(target, os.R_OK) and os.path.isfile(target)):
    die('File %s is not readable or does not exist' % target)

with open(target) as fd:
    filedata = list(fd.read())

# -h : ELF header
# -W : wide output
# -S : sections
cmd = [READELF, '-hWS', target]
out = check_output(cmd)

elfclass = re.findall('Class:\s*(.*$)', out, re.MULTILINE)[0]
entrypoint = int(re.findall('Entry point address:\s*(.*$)', out, re.MULTILINE)[0], 16)

field = '\s+(\S+)'
posint = '[123456789]\d*'
flags = '\s+([WAXMSILGTExOop]*)'
sections = {}
lines = re.findall('^\s+\[\s*' + posint + '\]' + field * 6 + flags, out, re.MULTILINE)
print 'Finding executable sections'
for name, _type, addr, off, size, _es, flgs in lines:
    if 'X' not in flgs: continue
    print '  %s' % name
    addr = int(addr, 16)
    off = int(off, 16)
    size = int(size, 16)
    def patch(p, s):
        if p < addr or p + len(s) > addr + size:
            raise ValueError
        s = list(s)
        fileaddr = p - addr + off
        filedata[fileaddr:fileaddr+len(s)] = s
    sections[name] = {'addr' : addr,
                     'offset': off,
                     'size'  : size,
                     'patch' : patch,
                     }

DecodeBits = Decode64Bits if elfclass == 'ELF64' else Decode32Bits

print 'Disassembling sections'
for name, sec in sections.items():
    print '  %s' % name
    addr = sec['addr']
    offset = sec['offset']
    size = sec['size']
    sec['code'] = Decode(addr, ''.join(filedata[offset:offset + size]), DecodeBits)

legit = []

print 'Searching for call and return instructions'
for name, sec in sections.items():
    addr = sec['addr']
    print '  %s' % name
    for iaddr, size, code, raw in sec['code']:
        if code.startswith('CALL'):
            print '    0x%08x CALL' % iaddr
            print ' 0x%08x' % (iaddr + size)
            legit.append(iaddr + size)
        elif code == 'RET':
            print '    0x%08x RET' % iaddr
            fileaddr = iaddr - addr + sec['offset']
            # filedata[fileaddr] = '\xcc'
            filedata[fileaddr] = '\xf4'

pages = (len(filedata) - 1) // PAGE_SIZE + 1
bootaddr = pages * PAGE_SIZE
print 'ELF file is %d bytes, padding to %d pages' % (len(filedata), pages)
filedata += '\0' * (bootaddr - len(filedata))


print 'Assembling dummy loader to determine size'
with open('loader.asm') as f:
    code = f.read()
code = code.replace('#OFFSET#', str(bootaddr)).replace('#LENGTH#', '0')
loaderlen = len(asm(code))
print '  Loader size: %d bytes' % loaderlen


print 'Looking up _start, and copying original code'
for name, sec in sections.items():
    addr = sec['addr']
    size = sec['size']
    offset = sec['offset']
    if entrypoint >= addr and entrypoint < addr + size:
        if entrypoint + loaderlen > addr + size:
            print '!! Section %s is not big enough to hold loader' % name
            exit()
        origaddr = entrypoint - addr + offset
        origcode = filedata[origaddr:origaddr + loaderlen]
        break


print 'Creating bootstrapper'
with open('bootstrapper.asm') as f:
    code = f.read()

print '  Legitimate return addresses: %d' % len(legit)
code = code.replace('#RETURN_ADDRS#',
                    ', '.join('0x%08x' % addr for addr in sorted(legit)))
print '  Entry point: 0x%08x' % entrypoint
code = code.replace('#ENTRY_POINT#',
                    '0x%08x' % entrypoint)
code = code.replace('#ORIG_CODE#',
                    ', '.join('0x%02x' % ord(c) for c in origcode))
boot = asm(code)
bootlen = len(boot)
print '  Appended bootstrapper: %d bytes' % len(boot)
filedata += boot


print 'Creating loader'
with open('loader.asm') as f:
    code = f.read()
code = code.replace('#OFFSET#', str(bootaddr)).replace('#LENGTH#', str(bootlen))
loader = asm(code)
if len(loader) <> loaderlen:
    print '!! Real loader is not the same size as dummy loader -- this is a BUG'
    exit()
filedata[origaddr:origaddr + loaderlen] = list(loader)
print '  Wrote %d bytes loader at _start' % loaderlen


print 'Writing ELF file'
# with open(target, 'w') as f:
with open('out', 'w') as f:
    f.write(''.join(filedata))
print '  DONE!'
