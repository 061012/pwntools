#!/usr/bin/env python
from distorm3 import Decode, Decode32Bits, Decode64Bits
from subprocess import check_output
from mmap import mmap
import sys, os, re, tempfile

READELF = '/usr/bin/readelf'
PAGE_SIZE = 4096

def nasm(s):
    with tempfile.NamedTemporaryFile() as tmp:
        tmp.write(s)
        tmp.flush()
        r = check_output(['nasm', '-o', '/dev/stdout', tmp.name])
    return r

def die(s):
    print s
    exit(0)

if not (os.access(READELF, os.X_OK) and os.path.isfile(READELF)):
    die('Missing /usr/bin/readelf, please install binutils')

target = sys.argv[1]

if not (os.access(target, os.R_OK) and os.path.isfile(target)):
    die('File %s is not readable or does not exist' % target)

with open(target) as fd:
    filedata = list(fd.read())

# -h : ELF header
# -W : wide output
# -S : sections
cmd = [READELF, '-hWS', target]
out = check_output(cmd)

elfclass = re.findall('Class:\s*(.*$)', out, re.MULTILINE)[0]
entrypoint = int(re.findall('Entry point address:\s*(.*$)', out, re.MULTILINE)[0], 16)

field = '\s+(\S+)'
posint = '[123456789]\d*'
flags = '\s+([WAXMSILGTExOop]*)'
sections = {}
lines = re.findall('^\s+\[\s*' + posint + '\]' + field * 6 + flags, out, re.MULTILINE)
print 'Finding executable sections'
for name, _type, addr, off, size, _es, flgs in lines:
    if 'X' not in flgs: continue
    addr = int(addr, 16)
    off = int(off, 16)
    size = int(size, 16)
    if name == '.plt':
        plt = (addr, size)
    print '  %s' % name
    sections[name] = {'addr' : addr,
                     'offset': off,
                     'size'  : size,
                     }

def inplt(p):
    return p is not None and p >= plt[0] and p < plt[0] + plt[1]

DecodeBits = Decode64Bits if elfclass == 'ELF64' else Decode32Bits

print 'Disassembling sections'
for name, sec in sections.items():
    print '  %s' % name
    addr = sec['addr']
    offset = sec['offset']
    size = sec['size']
    code = Decode(addr, ''.join(filedata[offset:offset + size]), DecodeBits)
    sec['code'] = {iaddr: (isize, asm) for iaddr, isize, asm, _raw in code}

legit = []

print 'Searching for call instructions'
for name, sec in sections.items():
    addr = sec['addr']
    print '  %s' % name
    for iaddr, (isize, asm) in sec['code'].items():
        if asm.startswith('CALL'):
            print '    0x%08x' % iaddr
            legit.append(iaddr + isize)
        # elif asm == 'RET':
        #     print '    0x%08x RET' % iaddr
        #     fileaddr = iaddr - addr + sec['offset']
        #     filedata[fileaddr] = '\xcc'
        #     # filedata[fileaddr] = '\xf4'


def nextcall(p, code):
    while True:
        try:
            isize, asm = code[p]
        except:
            break
        if asm.startswith('CALL'):
            m = re.findall('CALL 0x([0-9a-fA-F]+)', asm)
            if m <> []:
                return int(m[0], 16)
            break
        p += isize

def trace(p):
    traced = set()
    poi = set([(p, False)])
    while len(poi) > 0:
        p, dopatch = poi.pop()
        if p in traced:
            continue
        # print '0x%08x' % p
        for name, sec in sections.items():
            addr = sec['addr']
            size = sec['size']
            if p < addr or p >= addr + size: continue
            code = sec['code']
            while True:
                if p in traced:
                    break
                traced.add(p)
                try:
                    isize, asm = code[p]
                except:
                    # print hex(p)
                    break
                if asm == 'RET' or asm.startswith('RET 0x'):
                    if dopatch:
                        print '  0x%08x' % p
                        fileaddr = p - addr + sec['offset']
                        filedata[fileaddr] = '\xcc'
                    break
                else:
                    for s in re.findall('0x([0-9a-fA-F]+)', asm):
                        # heuristic here: if the next call is in a library we
                        # might be looking at an argument here, and that
                        # argument might be used as a callback -- so skip it
                        if not inplt(nextcall(p, code)):
                            poi.add((int(s, 16), True))
                p += isize

print 'Looking up main'
# -s : symbols
cmd = [READELF, '-s', target]
out = check_output(cmd)

main = re.findall('^\s+\d+:\s+([0-9a-f]+)\s+\d+\s+\w+\s+\w+\s+\w+\s+\w+\s+main$', out, re.MULTILINE)
if main == []:
    main = int(raw_input('Could not find main, please gief (0xXXXXXXXX): '), 16)
else:
    main = int(main[0], 16)
    print '  0x%08x' % main

print 'Tracing program to find return instructions'
trace(main)

# def patchret(p):
#     for name, sec in sections.items():
#         addr = sec['addr']
#         size = sec['size']
#         if p < addr or p >= addr + size: continue
#         code = sec['code']
#         try:
#             while True:
#                 # print '0x%08x' % p
#                 isize, asm = code[p]
#                 if asm == 'RET' or asm.startswith('RET 0x'):
#                     print '  0x%08x' % p
#                     fileaddr = p - addr + sec['offset']
#                     filedata[fileaddr:fileaddr + isize] = ['\xcc'] * isize
#                     return
#                 p += isize
#         except:
#             pass

# print 'Searching for return instructions'
# for name, sec in sections.items():
#     print '  %s' % name
#     for addr, (size, asm) in sec['code'].items():
#         for p in re.findall('0x([0-9a-fA-F]+)', asm):
#             patchret(int(p, 16))

pages = (len(filedata) - 1) // PAGE_SIZE + 1
bootaddr = pages * PAGE_SIZE
print 'ELF file is %d bytes, padding to %d pages' % (len(filedata), pages)
filedata += '\0' * (bootaddr - len(filedata))


print 'Assembling dummy loader to determine size'
with open('loader.asm') as f:
    code = f.read()
code = code.replace('#OFFSET#', str(bootaddr)).replace('#LENGTH#', '0')
loaderlen = len(nasm(code))
print '  Loader size: %d bytes' % loaderlen


print 'Looking up _start, and copying original code'
for name, sec in sections.items():
    addr = sec['addr']
    size = sec['size']
    offset = sec['offset']
    if entrypoint >= addr and entrypoint < addr + size:
        if entrypoint + loaderlen > addr + size:
            print '!! Section %s is not big enough to hold loader' % name
            exit()
        origaddr = entrypoint - addr + offset
        origcode = filedata[origaddr:origaddr + loaderlen]
        break


print 'Creating bootstrapper'
with open('bootstrapper.asm') as f:
    code = f.read()

print '  Legitimate return addresses: %d' % len(legit)
code = code.replace('#RETURN_ADDRS#',
                    ', '.join('0x%08x' % addr for addr in sorted(legit)))
print '  Entry point: 0x%08x' % entrypoint
code = code.replace('#ENTRY_POINT#',
                    '0x%08x' % entrypoint)
code = code.replace('#ORIG_CODE#',
                    ', '.join('0x%02x' % ord(c) for c in origcode))
boot = nasm(code)
bootlen = len(boot)
print '  Appended bootstrapper: %d bytes' % len(boot)
filedata += boot


print 'Creating loader'
with open('loader.asm') as f:
    code = f.read()
code = code.replace('#OFFSET#', str(bootaddr)).replace('#LENGTH#', str(bootlen))
loader = nasm(code)
if len(loader) <> loaderlen:
    print '!! Real loader is not the same size as dummy loader -- this is a BUG'
    exit()
filedata[origaddr:origaddr + loaderlen] = list(loader)
print '  Wrote %d bytes loader at _start' % loaderlen


print 'Writing ELF file'
# with open(target, 'w') as f:
with open('out', 'w') as f:
    f.write(''.join(filedata))
print '  DONE!'
