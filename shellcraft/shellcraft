#!/usr/bin/env python
import os, sys, types
from binascii import hexlify, unhexlify

def _usage ():
    print 'Usage: %s [option [...]] <shellcode> [arg [...]]' % sys.argv[0]
    print '  Options:'
    print '    -o, --out <file>'
    print '      Output file (default: stdout)'
    print '    -l, --list'
    print '      List available shellcodes'
    print '    -f, --format <format>'
    print '      r: raw (default)'
    print '      s: String'
    print '      c: C array'
    print '      h: Hex string'
    print '      a: Assembler code (do not assemble)'
    print '    -h, --help [<shellcode>]'
    print '      Show this help message or the docstring for the given shellcode'
    print '    -d, --debug'
    print '      Debug mode'
    print '    -t, --trap'
    print '      Insert software breakpoint before shellcode'
    print '  Example:'
    print '    shellcraft linux.bindshell'
    exit(0)

def _string(s):
    out = []
    for c in s:
        co = ord(c)
        if co >= 0x20 and co <= 0x7e:
            out.append(c)
        else:
            out.append('\\x%02x' % co)
    return '"' + ''.join(out) + '"'

def _raw(s):
    return s

def _carray(s):
    out = []
    for c in s:
        out.append('0x' + hexlify(c))
    return '{' + ', '.join(out) + '};\n'

def _hex(s):
    return hexlify(s) + '\n'

if __name__ == '__main__':
    args_ = sys.argv[1:]
    args = []
    i = 0
    out = '/dev/stdout'
    help = False
    format = _raw
    debug = False
    trap = False
    loop = False
    emit_asm = False
    def setout(file):
        global out
        out = abspath(join(os.getcwd(), file))
    def setfmt(fmt):
        global format, emit_asm
        if   fmt == 'r' or fmt == 'raw':
            format = _raw
        elif fmt == 's':
            format = _string
        elif fmt == 'c':
            format = _carray
        elif fmt == 'h' or fmt == 'hex':
            format = _hex
        elif fmt == 'a' or fmt == 'asm':
            format = _raw
            emit_asm = True
        else:
            print 'Unsupported format: %s' % fmt
            exit(0)

    while i < len(args_):
        a = args_[i]
        if   a in ['-o', '--out']:
            i += 1
            setout(args_[i])
        elif a.startswith('-o'):
            setout(args_[i][2:])
        elif a in ['-l', '--list']:
            from _shellcraft_list import shellcraft_list
            for x in shellcraft_list():
                print x
            exit(0)
        elif a in ['-f', '--format']:
            i += 1
            setfmt(args_[i])
        elif a.startswith('-f'):
            setfmt(args_[i][2:])
        elif a in ['-h', '--help']:
            help = True
        elif a in ['-d', '--debug']:
            debug = True
        elif a in ['-t', '--trap']:
            trap = True
        elif a in ['--loop']:
            loop = True
        else:
            args.append(a)
        i += 1

    name = args[0]

    if len(args) > 0:
        try:
            arch, platform, which = name.split('.', 2)
        except ValueError:
            print 'Name must be of the form <arch>.<platform>.<shellcode>'
            exit(0)
        try:
            module = __import__('pwn.' + arch + '.' + platform,
                                fromlist = ['_header', '_assemble', which]
                                )
        except:
            raise
        # except Exception, e:
        #     print 'Could not load "%s":' % args[0]
        #     print e
        #     exit(0)
    else:
        _usage()

    try:
        codefun = module.__getattribute__(which)
        if type(codefun) <> types.FunctionType:
            raise AttributeError
    except AttributeError:
        print 'No such code for %s.%s: %s' % (arch, platform, which)
        exit(0)

    if help:
        if len(args) > 0:
            doc = codefun.__doc__
            if doc:
                print doc
            else:
                print 'No docstring defined for "%s"' % name
            exit(0)
        else:
            _usage()

    try:
        code = codefun(*args[1:])
    except TypeError, e:
        if   str(e).startswith(which):
            print 'Wrong number of arguments'
            doc = codefun.__doc__
            if doc:
                print doc
        elif str(e).startswith("'NoneType'"):
            print 'Module "%s" returned None (did you remember "return"?)' % name
        else:
            raise
        exit(0)

    # TODO: make this architechture independant
    if trap:
        code = '\xcc' + code
    if loop:
        code += '\xeb\xfe'

    res = module.assemble(code, emit_asm = emit_asm)

    with open(out, 'w') as f:
        f.write(format(res))
