#!/usr/bin/env python

import os, sys, subprocess, warnings, struct, random
from os.path import join, abspath, relpath, isfile, splitext
from binascii import hexlify, unhexlify
from core import *

# Supress tmpnam warning
warnings.filterwarnings('ignore', category=RuntimeWarning)

INCLUDE   = join(sys.path[0], INCLUDE)
TEMPLATES = join(sys.path[0], TEMPLATES)

_GLUE, _TEMPLATE = range(2)

def _glue (code):
    if code == '':
        return ''
    return ';;; BEGIN GLUE\n' + \
        code + '\n'

def _template (templ, args):
    with open(join(TEMPLATES, templ), 'r') as f:
        code = f.read()
    for k, v in args.items():
        code = code.replace('#' + k.upper(), str(v))
    code = \
        ';;; BEGIN TEMPLATE %s\n' % templ + \
        code
    if not code[-1] == '\n':
        code += '\n'
    return code

def _header(arch, platform):
    hdr = []
    if platform == 'LINUX':
        if   arch == 'I386':
            hdr.append('%include "linux/32.asm"')
            hdr.append('bits 32')
        elif arch == 'AMD64':
            hdr.append('%include "linux/64.asm"')
            hdr.append('bits 64')
        else:
            print 'Unsupported architechture under Linux: %s' % arch
            exit(0)
        hdr.append('%include "macros/nasm.asm"')
    else:
        print 'Unsupported platform: %s' % platform
        exit(0)
    return '\n'.join(hdr)

def _nasm(src, debug):
    out = ['nasm']
    if debug:
        out += ['-D', 'DEBUG']
    out += ['-I', INCLUDE + '/', '-o' ,'/dev/stdout', src]
    return out

def _assembler(arch):
    if   arch in ['I386', 'AMD64']:
        return _nasm
    else:
        print 'Unsupported architechture: %s' % arch
        exit(0)

def _assemble(debug, emit_asm, arch, platform, code):
    src = os.tmpnam()
    hdr = _header(arch, platform)
    cmd = _assembler(arch)(src, debug)
    code = '\n'.join(
        [';;; Assemble with:\n;;;   %s' % ' '.join(cmd),
         hdr,
         code])

    if emit_asm:
        return code

    with open(src, 'w') as f:
        f.write(code)

    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    ret = p.wait()
    if ret <> 0:
        err = p.stderr.read()
        sys.stdout.write(err)
        exit(0)
    os.unlink(src)
    return p.stdout.read()

def _usage ():
    print 'Usage: %s [option [...]] <shellcode> [arg [...]]' % sys.argv[0]
    print '  Options:'
    print '    -o, --out <file>'
    print '      Output file (default: stdout)'
    print '    -l, --list'
    print '      List available shellcodes'
    print '    -f, --format <format>'
    print '      r: raw (default)'
    print '      s: String'
    print '      c: C array'
    print '      h: Hex string'
    print '      a: Assembler code (do not assemble)'
    print '    -h, --help [<shellcode>]'
    print '      Show this help message or the docstring for the given shellcode'
    print '    -d, --debug'
    print '      Debug mode'
    print '    -t, --trap'
    print '      Insert software breakpoint before shellcode'
    print '  Example:'
    print '    shellcraft linux.bindshell'
    exit(0)

def _string(s):
    out = []
    for c in s:
        co = ord(c)
        if co >= 0x20 and co <= 0x7e:
            out.append(c)
        else:
            out.append('\\x%02x' % co)
    return '"' + ''.join(out) + '"'

def _raw(s):
    return s

def _carray(s):
    out = []
    for c in s:
        out.append('0x' + hexlify(c))
    return '{' + ', '.join(out) + '};\n'

def _hex(s):
    return hexlify(s) + '\n'

if __name__ == '__main__':
    args_ = sys.argv[1:]
    args = []
    i = 0
    out = '/dev/stdout'
    help = False
    format = _raw
    debug = False
    trap = False
    loop = False
    emit_asm = False
    def setout(file):
        global out
        out = abspath(join(os.getcwd(), file))
    def setfmt(fmt):
        global format, emit_asm
        if   fmt == 'r' or fmt == 'raw':
            format = _raw
        elif fmt == 's':
            format = _string
        elif fmt == 'c':
            format = _carray
        elif fmt == 'h' or fmt == 'hex':
            format = _hex
        elif fmt == 'a' or fmt == 'asm':
            format = _raw
            emit_asm = True
        else:
            print 'Unsupported format: %s' % fmt
            exit(0)

    while i < len(args_):
        a = args_[i]
        if   a in ['-o', '--out']:
            i += 1
            setout(args_[i])
        elif a.startswith('-o'):
            setout(args_[i][2:])
        elif a in ['-l', '--list']:
            from _shellcraft_list import shellcraft_list
            for x in shellcraft_list():
                print x
            exit(0)
        elif a in ['-f', '--format']:
            i += 1
            setfmt(args_[i])
        elif a.startswith('-f'):
            setfmt(args_[i][2:])
        elif a in ['-h', '--help']:
            help = True
        elif a in ['-d', '--debug']:
            debug = True
        elif a in ['-t', '--trap']:
            trap = True
        elif a in ['--loop']:
            loop = True
        else:
            args.append(a)
        i += 1

    if len(args) > 0:
        try:
            module = __import__(CODEZ + '.' + args[0], fromlist=['main', 'arch', 'platform'])
        except Exception, e:
            print 'Could not load "%s":' % args[0]
            print e
            exit(0)
    else:
        _usage()

    if help:
        if len(args) > 0:
            doc = module.main.__doc__
            if doc:
                print doc
            else:
                print 'No docstring defined for "%s"' % name
            exit(0)
        else:
            _usage()

    try: # TODO: make this architechture independant
        if trap:
            pieces = glue('int3')
        else:
            pieces = []
        pieces += module.main(*args[1:])
        if loop:
            lbl = 'loop%d' % random.randint(0, 999999)
            pieces += glue('%s: jmp short %s' % (lbl, lbl))
    except AttributeError, e:
        if str(e).startswith("'module'"):
            print 'Module "%s" does not implement "main"' % name
        else:
            raise
        exit(0)
    except TypeError, e:
        if   str(e).startswith('main'):
            print 'Wrong number of arguments'
            doc = module.main.__doc__
            if doc:
                print doc
        elif str(e).startswith("'NoneType'"):
            print 'Module "%s" returned None (did you remember "return"?)' % name
        else:
            raise
        exit(0)

    arch = module.arch
    platform = module.platform

    code = []
    for (type, args) in pieces:
        if   type == _GLUE:
            code.append(_glue(*args))
        elif type == _TEMPLATE:
            code.append(_template(*args))
        else:
            raise TypeError
    code = ''.join(code)
    res = _assemble(debug, emit_asm, arch, platform, code)

    with open(out, 'w') as f:
        f.write(format(res))
