#!/usr/bin/env python2

import argparse, sys
from pwnlib import context, asm

parser = argparse.ArgumentParser()
parser.add_argument(
    'lines',
    metavar='line',
    nargs='*',
    help='Lines to assemble. If none are supplied, use stdin'
)
parser.add_argument(
    "-f", "--format",
    help="Output format (defaults to hex for ttys, otherwise raw)",
    choices=['raw', 'hex']
)
parser.add_argument(
    "-o",
    metavar='file',
    help="Output file (defaults to stdout)",
    type=argparse.FileType('w'),
    default=sys.stdout
)
parser.add_argument(
    '-c', '--context',
    metavar = '<opt>',
    choices = context.__possible__['os'] + context.__possible__['arch'],
    default = [],
    action = 'append',
    help = 'The os/architecture the shellcode will run in (default: linux/i386), choose from: %s' % \
      ', '.join(context.__possible__['os'] + context.__possible__['arch'])
)

args = parser.parse_args()
arch = 'i386'
os = 'linux'

for c in args.context:
    if c in context.__possible__['os']:
        os = c
    else:
        arch = c

if args.format == None:
    if args.o.isatty():
        args.format = 'hex'
    else:
        args.format = 'raw'

if len(args.lines) > 0:
    data = '\n'.join(args.lines)
else:
    data = sys.stdin.read()

output = asm.asm(data.replace(';', '\n'), arch = arch, os = os)

if args.format == 'raw':
    args.o.write(output)
else:
    args.o.write(output.encode('hex') + '\n')
